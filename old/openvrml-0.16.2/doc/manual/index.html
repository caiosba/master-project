<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN"
               "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<title>OpenVRML: Main Page</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<link rel="icon" href="../vrml-16">
<link rel="start" href="http://openvrml.org/index" title="OpenVRML Home">
<link rel="prev" href="http://openvrml.org/discussion" title="Discussion">
<link rel="contents" href="index" title="Documentation Main Page">
<link rel="index" href="functions" title="OpenVRML Compound Members">
<link rel="appendix" href="conformance" title="Conformance Test Results">
<style type="text/css">
@import url("doxygen.css");
@import url("tabs.css");
@import url("http://openvrml.org/openvrml.css");

body, td {
  font-size: 100%;
}

p, center, td, th, ul, dl, div {
  font-family: inherit;
}

div.nav {
  background-color: transparent;
  text-align: left;
  margin-top: 1em;
  margin-bottom: 1em;
  border-color: black;
  border-left: none;
  border-right: none;
  padding-top: 0.5em;
  padding-bottom: 0.5em;
}

div.nav a.el:link, div.nav a.el:visited {
  border-width: 1px;
  border-style: solid;
  border-color: silver;
  padding: 2px;
}

div.nav a.el:link:hover, div.nav a.el:visited:hover {
  border-style: outset;
  border-color: gray;
}

div.nav a.el:active {
  border-style: inset;
  border-color: gray;
}

.body td {
  background-color: transparent;
}

div.qindex {
  background-color: transparent;
  border: none;
}
a {
  color: inherit;
}
a.qindex {
  text-decoration: inherit;
  color: inherit;
  padding: 0;
}
a.qindex:visited {
  text-decoration: inherit;
  font-weight: inherit;
  color: inherit;
  padding: 0;
}
a.qindex:hover {
  text-decoration: inherit;
  background-color: transparent;
  padding: 0;
}
a.qindexHL {
  text-decoration: inherit;
  font-weight: inherit;
  background-color: transparent;
  color: inherit;
  padding: 0;
}
a.qindexHL:hover {
  text-decoration: inherit;
  background-color: transparent;
  color: inherit;
  padding: 0;
}
a.qindexHL:visited {
  text-decoration: inherit;
  background-color: transparent;
  color: inherit;
}
a.el {
  text-decoration: inherit;
  font-weight: inherit
}
a.elRef {
  font-weight: inherit
}
a.code {
  text-decoration: inherit;
  font-weight: inherit;
  color: inherit;
}
a.codeRef {
  font-weight: normal;
  color: inherit;
}
a:hover {
  text-decoration: inherit;
  background-color: inherit;
}

h1 {
  line-height: 1.2em;
}

div.qindex {
  font-size: smaller;
}

div.qindex .qindex:link, div.qindex .qindex:visited {
  font-weight: inherit;
}

div.qindex .qindexHL:link, div.qindex .qindexHL:visited {
  font-weight: bold;
}

.memItemLeft, .memItemRight,
.memTemplParams, .memTemplItemLeft, .memTemplItemRight,
.memproto, .memproto td {
  font-family: "Bitstream Vera Sans Mono",
               "LucidaTypewriter",
               "Lucida Console",
               monospace;
}

td.memItemLeft, td.memItemRight, td.mdescLeft, td.mdescRight {
  background-color: rgb(95%, 95%, 95%);
}

.mdTable {
  background-color: rgb(95%, 95%, 95%);
}

.memproto td code {
  font-family: sans-serif;
  font-style: italic;
}

td.pass {
  background-color: rgb(50%, 100%, 50%);
}

td.fail {
  background-color: rgb(100%, 50%, 50%);
}

td.invalid {
  background-color: rgb(75%, 75%, 75%);
}

.memitem {
  background-color: rgb(95%, 95%, 95%);
  border-color: rgb(80%, 80%, 80%);
}

.memproto {
  background-color: rgb(90%, 90%, 90%);
  border-color: rgb(65%, 65%, 65%);
  font-weight: inherit;
}

.memname {
  font-weight: inherit;
}

div.tabs {
  background-image: url("tab_b-openvrml.png");
}

div.tabs span {
  background-image: url("tab_l-openvrml.png");
}

div.tabs a {
  background-image: url("tab_r-openvrml.png");
  border-bottom: 1px solid #a5a5a5;
}

div.tabs a:link, div.tabs a:visited, div.tabs a:active, div.tabs a:hover {
  color: black;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}
</style>
</head>
<body>
<table class="sitenav">
  <tr>
    <th><a href="http://openvrml.org/index" title="Home">Home</a></th>
    <th><a href="http://openvrml.org/download" title="Download">Download</a></th>
    <th><a href="http://openvrml.org/screenshots/index" title="Screen shots">Screen shots</a></th>
    <th><a href="http://openvrml.org/discussion" title="Mailing lists and IRC">Discussion</a></th>
    <th>Documentation</th>
  </tr>
</table>
<div class="body">
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul></div>
<h1>OpenVRML Documentation</h1>
<p>
<h3 align="center">0.16.2 </h3>OpenVRML comprises a runtime library for VRML97 along with an OpenGL renderer.<h2><a class="anchor" name="contents">
Contents</a></h2>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="index.html#intro">1 Introduction</a> </td></tr>
<tr>
<td><a class="el" href="index.html#history">1.1 History</a> </td></tr>
<tr>
<td><a class="el" href="index.html#getting_started">2 Getting started</a> </td></tr>
<tr>
<td><a class="el" href="index.html#resource_fetching">2.1 Fetching network resources</a> </td></tr>
<tr>
<td><a class="el" href="index.html#resource_fetching_rationale">2.1.1 Rationale</a> </td></tr>
<tr>
<td><a class="el" href="index.html#introducing_resource_istream">2.1.2 Introducing resource_istream</a> </td></tr>
<tr>
<td><a class="el" href="index.html#introducing_browser">2.1.3 Introducing browser</a> </td></tr>
<tr>
<td><a class="el" href="index.html#resource_istream_impl_considerations">2.1.4 resource_istream implementation considerations</a> </td></tr>
<tr>
<td><a class="el" href="conformance.html">Conformance Test Results</a></td><td>NIST VRML Test Suite results </td></tr>
</table>
<h2><a class="anchor" name="intro">
1 Introduction</a></h2>
OpenVRML is a runtime library for VRML97 and X3D worlds. OpenVRML parses VRML/X3D directly into an in-memory scene graph format that can be further manipulated through its API and/or rendered.<h3><a class="anchor" name="history">
1.1 History</a></h3>
OpenVRML was started as LibVRML97 by Chris Morley. Since 2000 it has been maintained by Braden McDaniel.<h2><a class="anchor" name="getting_started">
2 Getting started</a></h2>
<h3><a class="anchor" name="resource_fetching">
2.1 Fetching network resources</a></h3>
<h4><a class="anchor" name="resource_fetching_rationale">
2.1.1 Rationale</a></h4>
A VRML/X3D runtime must, of course, be able to fetch network resources using URIs. However, there is no standard mechanism in C++ for network communication. Various libraries are available to fill this void; but if OpenVRML were to depend on one of them it could make OpenVRML more difficult to integrate into applications that use some different network layer.<p>
In order to integrate into systems using arbitrary mechanisms for network I/O, OpenVRML requires the user to supply a resource fetching facility. As such, the URI schemes (and corresponding resolution and transfer protocols) supported in worlds loaded into OpenVRML are a function of the user-supplied resource fetching mechanism.<p>
The resource fetching mechanism can be as full-featured or as spartan as the user application requires. A minimal facility might only handle <code>file</code> URLs. But in general it is desirable to support at least the schemes supported by modern Web browsers (significantly, <code>ftp</code> and <code>http</code>).<h4><a class="anchor" name="introducing_resource_istream">
2.1.2 Introducing resource_istream</a></h4>
OpenVRML accomplishes this extensibility by extending the C++ IOStreams framework. <code><a class="el" href="classopenvrml_1_1resource__istream.html">openvrml::resource_istream</a></code> inherits <code>std::istream</code> and adds a few member functions particular to network resource fetching:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">const</span> std::string url() const throw (std::bad_alloc);
 const std::string type() const throw (std::bad_alloc);
 <span class="keywordtype">bool</span> data_available() const throw ();
</pre></div><p>
<code>resource_istream</code> is an abstract class. It is an interface through which OpenVRML can access user code. You use <code>resource_istream</code> by inheriting it and providing implementations for its pure virtual functions.<h4><a class="anchor" name="introducing_browser">
2.1.3 Introducing browser</a></h4>
The centerpiece of the OpenVRML library is <code><a class="el" href="classopenvrml_1_1browser.html">openvrml::browser</a></code>. This class provides the interface for loading VRML/X3D worlds. Most management of the runtime will be handled through its member functions. Like <code>resource_istream</code>, <code>browser</code> is an abstract class that users must inherit. However, <code>browser</code> has only one pure virtual function you must implement: the one responsible for creating <code>resource_istreams</code>.<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> std::auto_ptr&lt;resource_istream&gt; do_get_resource(<span class="keyword">const</span> std::string &amp; uri) = 0;
</pre></div><p>
The API documentation for <code><a class="el" href="classopenvrml_1_1browser.html#02a063da7df8c4f8717051d4933321dc">openvrml::browser::do_get_resource</a></code> provides more details on the requirements for this function's implementation. Briefly, your implementation will return a <code>std::auto_ptr</code> to an instance of your class that implements <code><a class="el" href="classopenvrml_1_1resource__istream.html">openvrml::resource_istream</a></code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Most &ldquo;factory functions&rdquo; (i.e., functions that return an instance of an object allocated with <code>new</code>) in OpenVRML return an <code>auto_ptr</code>. <code>std::auto_ptr</code> is used for ownership transfer; its use for a return value signals that the caller is taking ownership of the resource.</dd></dl>
<h4><a class="anchor" name="resource_istream_impl_considerations">
2.1.4 resource_istream implementation considerations</a></h4>
OpenVRML supports a notion of data streaming. In general, network resources are read asynchronously with respect to the rendering thread. User code that does not support data streaming (as in the example using <code>std::filebuf</code> in the documentation for <code><a class="el" href="classopenvrml_1_1browser.html#02a063da7df8c4f8717051d4933321dc">openvrml::browser::do_get_resource</a></code>) can remain largely oblivious to synchronization issues. However, user code that supports data streaming must be mindful of the fact that OpenVRML uses separate threads to read the data streams. Care must be taken not to write to a buffer at the same time OpenVRML's stream reading thread is reading the buffer.<p>
The IOstreams framework is typically extended by inheriting <code>std::streambuf</code> to implement new sources and sinks for data. (Full treatment of this topic is beyond the scope of this document; see <a href="http://www.josuttis.com/libbook/"><em>The C++ Standard Library</em> by Nicolai M. Josuttis</a> and <a href="http://www.angelikalanger.com/iostreams.html"><em>Standard C++ IOStreams and Locales</em> by Angelika Langer and Klaus Kreft</a>.) However, <code>std::streambuf</code>'s interface is not thread-safe. Since OpenVRML's stream-reading thread can be expected to be using the <code>streambuf</code> interface (by way of the <code>std::istream</code> member functions inherited by <code><a class="el" href="classopenvrml_1_1resource__istream.html">openvrml::resource_istream</a></code>), it is only safe for user code to use the <code>streambuf</code> interface in that same thread; i.e., in code called by OpenVRML.<p>
If user code needs to feed data into a buffer in a separate thread, that buffer should not be the one managed by the <code>streambuf</code> interface (i.e., the buffer to which <code>eback</code>, <code>gptr</code>, and <code>egptr</code> point). In general it is appropriate to use a secondary buffer, protected with thread synchronization primitives, for writing incoming data. Data can then be moved from this buffer to the <code>streambuf</code>'s buffer in the implementation of <code>std::streambuf::underflow</code>. </div>
<address class="footer"><a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=7151&amp;type=3" width="125" height="37" border="0" alt="SourceForge.net Logo" align="right"></a><a href="http://sourceforge.net/tracker/?func=add&amp;group_id=7151&amp;atid=107151">Report error</a><br>Generated Tue Nov 28 16:06:21 2006 by Doxygen 1.5.1</address>
</body>
</html>
